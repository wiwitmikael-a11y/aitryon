
import type { VercelRequest, VercelResponse } from '@vercel/node';
import { GoogleGenAI, HarmCategory, HarmBlockThreshold, Type, Modality } from '@google/genai';
import {
    VIRTUAL_TRY_ON_MODEL,
    STOCK_PHOTO_MODEL,
    VIDEO_GENERATION_MODEL,
    TEXT_MODEL,
    ADVANCED_TEXT_MODEL
} from './lib/constants';

// Initialize the Google AI client with the API key from environment variables.
const ai = new GoogleGenAI({ apiKey: process.env.API_KEY! });

// Helper to extract base64 data and MIME type from data URLs.
const extractBase64 = (dataUrl: string) => dataUrl.split(',')[1];
const getMimeType = (dataUrl: string) => dataUrl.match(/data:(.*);base64,/)?.[1] || 'image/png';

// Define safety settings to be used for generative content calls.
const safetySettings = [
    { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_NONE },
    { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_NONE },
    { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_NONE },
    { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_NONE },
];

/**
 * Generates metadata (title, description, tags) for a given creative prompt.
 */
async function generateMetadata(prompt: string, type: 'photo' | 'video') {
    const instruction = `You are a digital asset manager. For the given creative prompt for a ${type}, generate metadata.
    Prompt: "${prompt}"
    Provide a concise and catchy title, a short description (1-2 sentences), and an array of 5-7 relevant keywords (tags).
    The tags should be single words or short phrases, all lowercase.
    Return the response as a JSON object.`;

    const response = await ai.models.generateContent({
        model: TEXT_MODEL,
        contents: instruction,
        config: {
            responseMimeType: 'application/json',
            responseSchema: {
                type: Type.OBJECT,
                properties: {
                    title: { type: Type.STRING },
                    description: { type: Type.STRING },
                    tags: { type: Type.ARRAY, items: { type: Type.STRING } }
                },
                required: ['title', 'description', 'tags']
            }
        },
        safetySettings,
    });

    return JSON.parse(response.text);
}

/**
 * Main handler for the Vercel serverless function.
 * It routes requests based on the 'task' field in the request body.
 */
export default async function handler(req: VercelRequest, res: VercelResponse) {
    if (req.method !== 'POST') {
        return res.status(405).json({ error: 'Method not allowed' });
    }

    try {
        const { task, ...payload } = req.body;

        switch (task) {
            case 'virtualTryOn': {
                const { personImage, productImage } = payload;
                if (!personImage || !productImage) {
                    return res.status(400).json({ error: 'Missing person or product image' });
                }

                const personImagePart = { inlineData: { data: extractBase64(personImage), mimeType: getMimeType(personImage) } };
                const productImagePart = { inlineData: { data: extractBase64(productImage), mimeType: getMimeType(productImage) } };
                const textPart = { text: 'Perform a virtual try-on. Take the clothing item from the second image and place it realistically on the person in the first image. Ensure the fit, drape, and lighting are natural. The output should be only the final image.' };

                const response = await ai.models.generateContent({
                    model: VIRTUAL_TRY_ON_MODEL,
                    contents: { parts: [personImagePart, productImagePart, textPart] },
                    config: { responseModalities: [Modality.IMAGE] },
                    safetySettings,
                });
                
                const imagePart = response.candidates?.[0]?.content.parts.find(p => p.inlineData);
                if (!imagePart || !imagePart.inlineData) {
                    throw new Error('No image generated by the model.');
                }
                
                const resultImage = `data:${imagePart.inlineData.mimeType};base64,${imagePart.inlineData.data}`;
                return res.status(200).json({ resultImage });
            }

            case 'generateCreativeStrategy': {
                const { topic, photoCount, videoCount } = payload;
                const prompt = `You are an expert creative director for a marketing agency. Based on the campaign topic "${topic}", generate a list of creative prompts for visual assets. Provide ${photoCount} distinct prompts for stock photos and ${videoCount} distinct prompts for short promotional videos (5-10 seconds). Each prompt should be concise, descriptive, and visually evocative. Focus on creating a cohesive set of assets that tell a story or explore different facets of the campaign topic. Return the response as a JSON object.`;
                
                const response = await ai.models.generateContent({
                    model: ADVANCED_TEXT_MODEL,
                    contents: prompt,
                    config: {
                        responseMimeType: 'application/json',
                        responseSchema: {
                            type: Type.OBJECT,
                            properties: {
                                photoPrompts: { type: Type.ARRAY, items: { type: Type.STRING } },
                                videoPrompts: { type: Type.ARRAY, items: { type: Type.STRING } }
                            },
                            required: ['photoPrompts', 'videoPrompts']
                        }
                    },
                    safetySettings,
                });
                return res.status(200).json(JSON.parse(response.text));
            }

            case 'generateMetadataForAsset': {
                const { prompt, type } = payload;
                const metadata = await generateMetadata(prompt, type);
                return res.status(200).json(metadata);
            }

            case 'generateStockImage': {
                const { prompt, aspectRatio, generateMetadata } = payload;
                
                const imageResponse = await ai.models.generateImages({
                    model: STOCK_PHOTO_MODEL,
                    prompt: prompt,
                    config: {
                        numberOfImages: 1,
                        aspectRatio: aspectRatio,
                        outputMimeType: 'image/png',
                    },
                    safetySettings,
                });

                const imageBytes = imageResponse.generatedImages[0].image.imageBytes;
                const src = `data:image/png;base64,${imageBytes}`;

                if (generateMetadata) {
                    const metadata = await generateMetadata(prompt, 'photo');
                    return res.status(200).json({ src, metadata });
                }

                return res.status(200).json({ src });
            }
            
            case 'generatePhotoShootPackage': {
                const { aspectRatio } = payload;
                const themePrompt = `You are a photoshoot art director. Brainstorm a creative, visually compelling theme for a stock photography shoot. Then, based on that theme, generate 10 distinct, detailed photo prompts. Each prompt should describe a unique scene, subject, and mood that fits the overall theme. The theme should be a short, catchy phrase. The prompts should be varied. Return a JSON object.`;
                
                const promptsResponse = await ai.models.generateContent({
                    model: ADVANCED_TEXT_MODEL,
                    contents: themePrompt,
                    config: {
                        responseMimeType: 'application/json',
                        responseSchema: {
                            type: Type.OBJECT,
                            properties: {
                                theme: { type: Type.STRING },
                                prompts: { type: Type.ARRAY, items: { type: Type.STRING } }
                            },
                            required: ['theme', 'prompts']
                        }
                    },
                    safetySettings,
                });

                const { theme, prompts } = JSON.parse(promptsResponse.text);

                const imagePromises = prompts.map((p: string) => 
                    ai.models.generateImages({
                        model: STOCK_PHOTO_MODEL,
                        prompt: p,
                        config: { numberOfImages: 1, aspectRatio: aspectRatio, outputMimeType: 'image/png' },
                        safetySettings,
                    }).catch(e => ({ error: e, prompt: p }))
                );

                const imageResults = await Promise.all(imagePromises);

                const results = imageResults.map((result: any, i) => {
                    if (result.error) {
                        console.error(`Failed to generate image for prompt: "${result.prompt}"`, result.error);
                        return { id: `img-${i}`, prompt: prompts[i], src: '' };
                    }
                    const imageBytes = result.generatedImages[0].image.imageBytes;
                    return {
                        id: `img-${i}`,
                        prompt: prompts[i],
                        src: `data:image/png;base64,${imageBytes}`
                    };
                });
                return res.status(200).json({ theme, results });
            }

            case 'generateVideo': {
                const { prompt, aspectRatio } = payload;
                const operation = await ai.models.generateVideos({
                    model: VIDEO_GENERATION_MODEL,
                    prompt: prompt,
                    config: { numberOfVideos: 1, resolution: '1080p', aspectRatio: aspectRatio }
                });
                return res.status(200).json(operation);
            }

            case 'checkVideoOperationStatus': {
                const { operationName } = payload;
                if (!operationName) {
                    return res.status(400).json({ error: 'Missing operationName' });
                }
                const operation = await ai.operations.getVideosOperation({ name: operationName });
                return res.status(200).json(operation);
            }

            case 'fetchVideo': {
                const { uri } = payload;
                if (!uri) {
                    return res.status(400).json({ error: 'Missing URI' });
                }
                const response = await fetch(`${uri}&key=${process.env.API_KEY}`);
                if (!response.ok) {
                    throw new Error(`Failed to fetch video from URI: ${response.statusText}`);
                }
                const buffer = await response.arrayBuffer();
                const videoBytes = Buffer.from(buffer).toString('base64');
                return res.status(200).json({ videoBytes });
            }

            case 'generateCreativePrompt': {
                const { type } = payload;
                let subject = '';
                switch (type) {
                    case 'photo': subject = 'a single, highly detailed, visually stunning stock photo'; break;
                    case 'video': subject = 'a short, cinematic, 5-10 second video clip'; break;
                    case 'campaign': subject = 'a marketing campaign topic'; break;
                    default: return res.status(400).json({ error: 'Invalid prompt type' });
                }
                const instruction = `You are a world-class creative director. Brainstorm a single, unique, and compelling creative prompt for ${subject}. The prompt should be imaginative and detailed. Do not include any preamble or explanation. Just provide the prompt text itself. If it is a campaign topic, it should be a short, catchy phrase (e.g., "The Art of Stillness" or "Urban Oasis"). If it is a photo or video prompt, it should be a descriptive sentence or two.`;
                
                const response = await ai.models.generateContent({
                    model: TEXT_MODEL,
                    contents: instruction,
                    safetySettings,
                });
                
                const prompt = response.text.replace(/^["']|["']$/g, '').trim();
                return res.status(200).json({ prompt });
            }

            default:
                return res.status(400).json({ error: 'Invalid task specified' });
        }
    } catch (error) {
        console.error('API Error:', error);
        const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred';
        return res.status(500).json({ error: errorMessage });
    }
}
